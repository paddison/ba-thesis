# Bachelor-Thema: Seek-basierte parallele Pseudozufallszahlengeneratoren
## Motivation
Ausgangsgrund waren HPC-Anwendungen am HLRS, die aufgrund Ermangelung von brauchbaren parallelen Zufallszahlengeneratoren bislang auf sequentielle Zufallszahlen- generatoren zuru ̈ckfallen mussten. Der resultierende sequentielle Laufzeitanteil bei an- sonsten gut parallelisierten Anwendungen beeintr ̈achtigt aber wiederum die Gesamt- skalierbarkeit zu stark (siehe Amdahlsches Gesetz), um diese Anwendungen effizient auf einem großen Supercomputer wie “Hawk” zu nutzen. Dafu ̈r mu ̈sste dieser Teil auch noch parallelisiert werden. Als Vorarbeit dafu ̈r soll diese Bachelor-Arbeit dienen.
## Beschreibung
Einige Anwendungen (bspw. Monte-Carlo Simulationen) ben ̈otigen Zufallsdaten, die sie u ̈blicherweise mittels Pseudozufallszahlengeneratoren (kurz PRNG, engl. Pseudo- random number generator) erzeugen. Ausgehend von einem Startwert (dem Seed, x0) werden dabei durch eine bestimmte Formel f(x) nacheinander (d. h. meist implizit durch xn+1 = fi(xn)) weitere Werte berechnet, die zusammengenommen dann den gewu ̈nschten Zufallszahlenstream ergeben. Bei dem Versuch der Parallelisierung eines solchen PRNGs wird oft pro Thread oder Prozess einfach ein zuf ̈alliger, individueller Seed-Wert vergeben, in der Hoffnung, dass damit unabh ̈angige Zufallszahlenstreams erzeugt werden. Dafu ̈r gibt es aber keinerlei Garantien, sodass auch u ̈berlappende Streams entstehen k ̈onnen, die dann teilweise identische Zufallswerte liefern und mit dem daraus resultierenden Bias die Anwendungsergebnisse verzerren oder gar nutzlos machen. U ̈berdies gibt es leider auch keine Reproduzierbarkeit der Daten, z. B. bei Strong-Scaling Experimenten, weil durch diesen Ansatz die Zufallsdaten mit der Anzahl der Streams und damit der Parallelit ̈at variieren.
## Ansatz
In dieser Bachelor-Arbeit soll daher ein anderer Ansatz fu ̈r die Parallelisierung von Zufallszahlengeneratoren verfolgt werden. Dabei soll untersucht werden, welche impliziten PRNG-Formeln auch explizit dargestellt werden k ̈onnen, d. h. xn = fe(x0). Mit einer solchen Darstellung w ̈are es n ̈amlich m ̈oglich, den aktuellen Zustand n eines PRNG-Streams um eine beliebige Schrittweite nach vorne zu springen, ohne die dazwischenliegenden Werte zu berechnen. Wa ̈hlt man dann die Sprungweite pro Thread/Prozess groß genug, kann man sicherstellen, dass die einzelnen Streams sich nicht u ̈berlappen. Weiß man daru ̈ber hinaus exakt, wie viele Zufallszahlenwerte insgesamt zu erzeugen sind (bspw. bei Strong-Scaling), kann man mittels einer Prefixsumme die parallelen Streams so genau vorspulen, dass diese mathematisch aufeinanderfolgen. Dadurch bekommt man sogar immer reproduzierbar die gleichen Zufallsdaten, unabh ̈angig davon, wie viele Threads oder Prozesse diese Daten parallel erzeugen.
## Aufgaben
In dieser Arbeit sollen mehrere existierende PRNG auf deren Parallelisierungsm ̈oglichkeit nach diesem Ansatz untersucht werden und eine Sammlung von machbaren PPRNGs in Form einer Bibliothek implementiert werden. Darin sollte zumindest ein einfacher PPRNG (z. B. LCG-Typ wie drand48) enthalten sein und noch ein besserer PPRNG (wie bspw. KISS), der u. a. mit einer gr ̈oßeren Periode u ̈berhaupt erst fu ̈r echte HPC- Anwendungen infrage kommt. Die implementierten PPRNGs sollen auf Korrektheit getestet werde (z. B. entstehen bei Strong-Scaling die gleichen Daten wie beim se- quentiellen PRNG?), vermessen und miteinander verglichen werden. Optional kann die Arbeit auch erkl ̈aren, warum manche Zufallszahlengeneratoren (bspw. kryptografisch- sichere PRNGs) nach diesem Schema nicht parallelisiert werden k ̈onnen.
## Betreuer
Christian Siebert vom HLRS (christian.siebert@hlrs.de)
